Q 8.1 Name twodifferences between logical and physical addresses. 
A:
Differences between logical and physical addresses:

1. Logical address is the one which is not the real address. This means that the application or a process assumes that the address its using is real one, while its not. Logical address is also known as virtual address. On the other hand, physical address is the one which refers to the actual physical address in the physical memory.

2. Logical address is generated by the CPU, whereas physical address, which is seen by the memory unit, is generated by the memory-management unit (MMU).

Q 8.4 Consider a logical address space of 64 pages of 1024 words each, mapped onto a physical memory of 32 frames.
a.How many bits are there in the logical address?
b.How many bits are there in the physical address? 
A:
Logical address calculation:

There are 64 pages of 1024 words each = 64*1024 words = (2^6 * 2^10) words.

Thus, 6+10 = 16 bits are there in the logical address.

Physical address calculation:

There are 32 frames of 1024 words each = 32*1024 words = (2^5 * 2^10) words

Thus, 5+10 = 15 bits are there in the physical address.

Q 8.9 Explain the difference between internal and external fragmentation. 
A:
Whenever a memory is allocated, two general types of space wastage occur: Internal fragmentation and external fragmentation.

When the total memory space is available but in non-contiguous manner, its called external fragmentation. Thus, storage might get fragmented into a large number of small holes. This could be a severe problem as such fragmentation will lead to huge number of total memory wastage.

To avoid external fragmentation, memory space is divided into equal parts, also known as pages. Each process then receives memory at the granularity of a page. The wastage of memory inside these pages is called internal fragmentation.

Q 8.22 Explain why sharing a reentrant module is easier when segmentation is used than when pure paging is used.
A:
In segmentation, logical address space is a collections of segments, one for each of code, global variables, heap, stack etc. Thus, a reentrant module gets assigned a separate segment which only contains contents of the reentrant module. To share the reentrant module, OS simply needs to share the entire segment among the processes that use this module. Also, since no process will modify the contents of this reentrant segment, OS does not need to handle the situation where part of this shared segment gets modified by a process.

With pure paging, pages of memory are shared across processes. If reentrant module spans multiple pages, all pages need to be shared among processes that use this module. Also, it is very likely that the reentrant module shares the first and last page with address spaces of processes that are not reentrant and hence would be modified by the processes. When such is the case, the first and last page of the reentrant module cannot be shared across processes and need to be exclusively owned by each process.